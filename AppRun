#!/bin/bash
HERE="$(dirname "$(readlink -f "${0}")")"
MY_APPIMAGE_TMP_DIR="$HERE"_tmp
#===================================================================

# Create a tmp dir to some utils like vulkan:
if [ -d "$1" ]; then
	rm -rf "$MY_APPIMAGE_TMP_DIR"
fi
mkdir "$MY_APPIMAGE_TMP_DIR"

#===================================================================
# If not extract and overwrite, $HERE/lib is a link to $HERE/usr/lib, that link to $HERE/usr/lib64
export LD_LIBRARY_PATH="$HERE/usr/lib":$LD_LIBRARY_PATH
export LD_LIBRARY_PATH="$HERE/usr/lib32":$LD_LIBRARY_PATH
export LD_LIBRARY_PATH="$HERE/lib":$LD_LIBRARY_PATH
#----------------------------------------

#Sound Library
export LD_LIBRARY_PATH="$HERE/usr/lib32/pulseaudio":$LD_LIBRARY_PATH
export LD_LIBRARY_PATH="$HERE/usr/lib32/alsa-lib":$LD_LIBRARY_PATH

# libGL drivers
export LIBGL_DRIVERS_PATH="$HERE/usr/lib32/dri":$LIBGL_DRIVERS_PATH

#Font Config
export FONTCONFIG_PATH="$HERE/etc/fonts":$FONTCONFIG_PATH

#LD
export WINELDLIBRARY="$HERE/usr/lib32/ld-linux.so.2"
#----------------------------------------

# GStreamer environment variables
export GST_REGISTRY_REUSE_PLUGIN_SCANNER="no"
export GST_PLUGIN_SYSTEM_PATH_1_0="${HERE}/usr/lib32/gstreamer-1.0/"

export GST_PLUGIN_SCANNER_1_0="${HERE}/usr/lib32/gstreamer-1.0/gst-plugin-scanner"
export GST_PTP_HELPER_1_0="${HERE}/usr/lib32/gstreamer-1.0/gst-ptp-helper"

export GST_PLUGIN_PATH=${GST_PLUGIN_SYSTEM_PATH_1_0}
export GST_PLUGIN_SYSTEM_PATH=${GST_PLUGIN_SYSTEM_PATH_1_0}
export GST_PLUGIN_SCANNER=${GST_PLUGIN_SCANNER_1_0}
#===================================================================

# For Vulkan drivers:
# intel:
cat > $MY_APPIMAGE_TMP_DIR/intel_icd.i686.json << EOF
{
    "ICD": {
        "api_version": "1.1.102",
        "library_path": "$HERE/usr/lib32/libvulkan_intel.so"
    },
    "file_format_version": "1.0.0"
}
EOF

# radeon:
cat > $MY_APPIMAGE_TMP_DIR/radeon_icd.i686.json << EOF
{
    "ICD": {
        "api_version": "1.1.107",
        "library_path": "$HERE/usr/lib32/libvulkan_radeon.so"
    },
    "file_format_version": "1.0.0"
}
EOF
#----------------------------------------

# Setting just intel for now, it's the default. But the user can change the variable VK_ICD_FILENAMES
if [ -z "$VK_ICD_FILENAMES" ]
then
	export VK_ICD_FILENAMES="$MY_APPIMAGE_TMP_DIR/intel_icd.i686.json"
fi
#===================================================================

##Wine ENVs (see: https://wiki.winehq.org/Wine-Staging_Environment_Variables)
# arch and bottle first:
export WINEARCH=win32
if [ -z "$WINEPREFIX" ]
then
	export WINEPREFIX=~/.wine32
fi
#export WINEVERPATH=${WINEVERPATH:-"$HERE"}
export WINEVERPATH="$HERE"
export WINESERVER="$HERE/bin/wineserver"
export WINELOADER="$HERE/bin/wine"
export WINEPATH="$HERE/bin":"$HERE/lib/wine":"$WINEPATH"
export WINEDLLPATH="$HERE/lib/wine/fakedlls":"$WINEDLLPATH"
#export WINEDEBUG=${WINEDEBUG:-"-all"}
#export WINEDEBUG=fixme-all
#export WINEDLLOVERRIDES=${WINEDLLOVERRIDES:-"mscoree,mshtml="}
#export WINEESYNC=0
#export WINEESYNC=${WINEESYNC:-"1"}

export LD_LIBRARY_PATH="$HERE/lib/wine":$LD_LIBRARY_PATH
#----------------------------------------

# Load winecfg if no arguments given
APPLICATION=""
if [ -z "$*" ] ; then
	APPLICATION="winecfg"
fi

# Allow the AppImage to be symlinked to e.g., /usr/bin/wineserver
if [ -n "$APPIMAGE" ] ; then
	BINARY_NAME=$(basename "$ARGV0")
else
	BINARY_NAME=$(basename "$0")
fi

# change some scripts to exe executables
if [[ $1 =~ ^(winecfg|wineboot|regedit|regsvr32|msiexec|msidb|notepad|winefile|winemine)$ ]]; then
	args=( "$@" )
	args[0]="$1.exe"
	set "${args[@]}"
fi

if [ -n "$1" ] && [ -x "$HERE/bin/$1" ] ; then
	MAIN="$HERE/bin/$1" ; shift
elif [ -n "$1" ] && [ -x "$HERE/usr/bin/$1" ] ; then
	MAIN="$HERE/usr/bin/$1" ; shift
elif [ -x "$HERE/bin/$BINARY_NAME" ] ; then
	MAIN="$HERE/bin/$BINARY_NAME"
elif [ -x "$HERE/usr/bin/$BINARY_NAME" ] ; then
	MAIN="$HERE/usr/bin/$BINARY_NAME"
else
	MAIN="$HERE/bin/wine"
fi

# Exec outside apps with inside environment (make the link name "ExternalExec")
if [ "$BINARY_NAME" = "ExternalExec" ] && [ -n "$1" ] && [ -x "$1" ]; then
	MAIN="$1" ; shift
fi
#===================================================================

export PATH=$HERE/bin:$HERE/usr/bin:$PATH
if [ -z "$APPLICATION" ] ; then
	LD_PRELOAD="$HERE/bin/libhookexecv.so" "$WINELDLIBRARY" "$MAIN" "$@" | cat
else
	LD_PRELOAD="$HERE/bin/libhookexecv.so" "$WINELDLIBRARY" "$MAIN" "$APPLICATION" | cat
fi
#===================================================================

# clean tmp files:
rm -rf "$MY_APPIMAGE_TMP_DIR"
